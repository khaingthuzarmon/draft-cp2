# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GQV-J9sTibdLVuA3TgBGx4EOYU2BrdTT
"""

import streamlit as st
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestClassifier
from datetime import datetime

# --- 1. Data Loading and Preprocessing (condensed from your notebook) ---

@st.cache_data
def load_and_preprocess_data():
    # Load the dataset
    url = "Online Retail.xlsx" # Make sure this file is in the same directory
    df = pd.read_excel(url, engine='openpyxl')

    # Data cleaning
    df_clean = df.copy()
    df_clean = df_clean.dropna(subset=['CustomerID'])
    df_clean['Description'] = df_clean['Description'].fillna('Unknown Product')
    df_clean = df_clean.drop_duplicates()
    df_clean['CustomerID'] = df_clean['CustomerID'].astype(int)
    df_clean['InvoiceDate'] = pd.to_datetime(df_clean['InvoiceDate'])
    df_clean = df_clean[(df_clean['Quantity'] > 0) & (df_clean['UnitPrice'] > 0)]
    df_clean['InvoiceNo'] = df_clean['InvoiceNo'].astype(str)
    df_clean = df_clean[~df_clean['InvoiceNo'].str.startswith('C', na=False)]

    # Outlier capping
    qty_cap = df_clean['Quantity'].quantile(0.995)
    price_cap = df_clean['UnitPrice'].quantile(0.995)
    df_clean['Quantity_capped'] = df_clean['Quantity'].clip(upper=qty_cap)
    df_clean['UnitPrice_capped'] = df_clean['UnitPrice'].clip(upper=price_cap)

    # Create TotalAmount
    df_clean['TotalAmount'] = df_clean['Quantity_capped'] * df_clean['UnitPrice_capped']

    return df_clean

df_clean = load_and_preprocess_data()


# --- 2. RFM Calculation and Model Training ---

@st.cache_resource
def train_models(df):
    # RFM Calculation
    analysis_date = df['InvoiceDate'].max() + pd.DateOffset(days=1)
    rfm_df = df.groupby('CustomerID').agg(
        Recency=('InvoiceDate', lambda date: (analysis_date - date.max()).days),
        Frequency=('InvoiceNo', 'nunique'),
        Monetary=('TotalAmount', 'sum')
    ).reset_index()

    # Scaling RFM features
    scaler = StandardScaler()
    rfm_scaled = scaler.fit_transform(rfm_df[['Recency', 'Frequency', 'Monetary']])

    # K-means clustering
    kmeans = KMeans(n_clusters=4, random_state=42, n_init=10)
    rfm_df['Cluster'] = kmeans.fit_predict(rfm_scaled)

    # Prepare data for prediction model
    # Target: Will the customer purchase in the last 30 days of the dataset?
    target_date = df['InvoiceDate'].max() - pd.DateOffset(days=30)
    target_customers = df[df['InvoiceDate'] >= target_date]['CustomerID'].unique()
    rfm_df['target'] = rfm_df['CustomerID'].isin(target_customers).astype(int)

    # Train Random Forest
    X = rfm_df[['Recency', 'Frequency', 'Monetary', 'Cluster']]
    y = rfm_df['target']
    rf_model = RandomForestClassifier(random_state=42)
    rf_model.fit(X, y)

    return scaler, kmeans, rf_model

scaler, kmeans_model, rf_model = train_models(df_clean)

# --- 3. Streamlit UI ---

st.title("Customer Segmentation and Purchase Prediction App üõçÔ∏è")
st.write("Enter customer RFM values to predict their segment and likelihood of purchase.")

# User input
recency = st.number_input("Recency (days since last purchase)", min_value=0, value=30)
frequency = st.number_input("Frequency (number of purchases)", min_value=1, value=5)
monetary = st.number_input("Monetary (total spending)", min_value=0.0, value=500.0)

# Prediction button
if st.button("Predict"):
    # Create a dataframe from user input
    input_data = pd.DataFrame([[recency, frequency, monetary]], columns=['Recency', 'Frequency', 'Monetary'])

    # Scale the input
    input_scaled = scaler.transform(input_data)

    # Predict the cluster
    cluster = kmeans_model.predict(input_scaled)[0]
    st.write(f"**Predicted Customer Segment**: Cluster {cluster}")

    # Prepare data for RF model
    input_data_with_cluster = input_data.copy()
    input_data_with_cluster['Cluster'] = cluster

    # Predict purchase
    prediction = rf_model.predict(input_data_with_cluster)[0]
    probability = rf_model.predict_proba(input_data_with_cluster)[0][1]

    if prediction == 1:
        st.success(f"This customer is likely to purchase again! (Probability: {probability:.2%})")
    else:
        st.error(f"This customer is not likely to purchase again. (Probability of purchase: {probability:.2%})")